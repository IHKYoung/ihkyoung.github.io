<!DOCTYPE html>














<script>
    MathJax = {
        tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$'], ['\\[', '\\]']],
            processEscapes: true,
            processEnvironments: true
        },
        options: {
            skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        }
    };

    window.addEventListener('load', (event) => {
        document.querySelectorAll("mjx-container").forEach(function (x) {
            x.parentElement.classList += 'has-jax'
        })
    });
</script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>



<html lang="zh" dir="zh-cn">
<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Leetcode：80. 删除有序数组中的重复项 II | AhaKnow</title>
<meta name="keywords" content="双指针">
<meta name="description" content="一道值得反复品味的经典双指针算法">
<meta name="author" content="CKYoung">
<link rel="canonical" href="https://ahaknow.com/posts/know/leetcode-80-remove-duplicates-from-sorted-array-ii/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="https://ahaknow.com/Q.gif">
<link rel="icon" type="image/png" sizes="16x16" href="https://ahaknow.com/Q.gif">
<link rel="icon" type="image/png" sizes="32x32" href="https://ahaknow.com/Q.gif">
<link rel="apple-touch-icon" href="https://ahaknow.com/Q.gif">
<link rel="mask-icon" href="https://ahaknow.com/Q.gif">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://ahaknow.com/posts/know/leetcode-80-remove-duplicates-from-sorted-array-ii/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Leetcode：80. 删除有序数组中的重复项 II" />
<meta property="og:description" content="一道值得反复品味的经典双指针算法" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ahaknow.com/posts/know/leetcode-80-remove-duplicates-from-sorted-array-ii/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-04-12T13:19:53+08:00" />
<meta property="article:modified_time" content="2024-09-11T23:50:24+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Leetcode：80. 删除有序数组中的重复项 II"/>
<meta name="twitter:description" content="一道值得反复品味的经典双指针算法"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "🚀 天天向上",
      "item": "https://ahaknow.com/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "🌟知识",
      "item": "https://ahaknow.com/posts/know/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Leetcode：80. 删除有序数组中的重复项 II",
      "item": "https://ahaknow.com/posts/know/leetcode-80-remove-duplicates-from-sorted-array-ii/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Leetcode：80. 删除有序数组中的重复项 II",
  "name": "Leetcode：80. 删除有序数组中的重复项 II",
  "description": "一道值得反复品味的经典双指针算法",
  "keywords": [
    "双指针"
  ],
  "articleBody": "Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.\nReturn k after placing the final result in the first k slots of nums.\nDo not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\nCustom Judge:\nThe judge will test your solution with the following code:\nint[] nums = [...]; // Input array\rint[] expectedNums = [...]; // The expected answer with correct length\rint k = removeDuplicates(nums); // Calls your implementation\rassert k == expectedNums.length;\rfor (int i = 0; i \u003c k; i++) {\rassert nums[i] == expectedNums[i];\r} If all assertions pass, then your solution will be accepted.\nExample 1:\nInput: nums = [1,1,1,2,2,3]\rOutput: 5, nums = [1,1,2,2,3,_]\rExplanation: Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.\rIt does not matter what you leave beyond the returned k (hence they are underscores). Example 2:\nInput: nums = [0,0,1,1,1,1,2,3,3]\rOutput: 7, nums = [0,0,1,1,2,3,3,_,_]\rExplanation: Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively.\rIt does not matter what you leave beyond the returned k (hence they are underscores). Constraints:\n1 \u003c= nums.length \u003c= 3 * 104 -104 \u003c= nums[i] \u003c= 104 nums is sorted in non-decreasing order. 给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。\n不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。\n说明：\n为什么返回数值是整数，但输出的答案是数组呢？\n请注意，输入数组是以 「引用」 方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n你可以想象内部操作如下:\n// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝\rint len = removeDuplicates(nums);\r// 在函数里修改输入数组对于调用者是可见的。\r// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。\rfor (int i = 0; i \u003c len; i++) {\rprint(nums[i]);\r} 示例 1：\n输入：nums = [1,1,1,2,2,3]\r输出：5, nums = [1,1,2,2,3]\r解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3。 不需要考虑数组中超出新长度后面的元素。 示例 2：\n输入：nums = [0,0,1,1,1,1,2,3,3]\r输出：7, nums = [0,0,1,1,2,3,3]\r解释：函数应返回新长度 length = 7, 并且原数组的前七个元素被修改为 0, 0, 1, 1, 2, 3, 3。不需要考虑数组中超出新长度后面的元素。 提示：\n1 \u003c= nums.length \u003c= 3 * 104 -104 \u003c= nums[i] \u003c= 104 nums 已按升序排列 这和上一题的区别就是重复的元素只出现两次\n其实解题的本质和上一题是一样的，还是使用双指针，但是实现逻辑上稍有不同，需要注意‼️\n不管是只出现两次还是n次，\n因为是升序排列，只能出现一次是比较一次，那么只能出现两次那就判断两次\n但比较一次可以简化为比较不同，比较两次则要保证不受到原地替换的影响，在逻辑上有巧妙之处。\n🌽上菜 这个问题是前一个问题的一个变体，不同之处在于需要保留每个元素最多两次，而不是一次。因此，仍然可以采用双指针的方法来解决这个问题，只是需要对比较逻辑做一些调整，以确保每个元素最多出现两次。\n解题思路：\n使用两个指针 slow 和 fast。其中 slow 指针用来指示处理后的数组的末尾位置，而 fast 指针用来遍历整个数组。 需要确保 slow 指向的新数组中，每个元素最多出现两次。这可以通过比较 nums[fast] 与 nums[slow-2]（而不是 nums[slow-1]）来实现，因为这次是允许每个元素出现两次。 当 fast 指针指向的元素与 slow-2 指针指向的元素不同，或者 slow 小于2（意味着还没有填充两个元素）时，将 nums[fast] 的值复制到 nums[slow]，然后递增 slow。 需要特别注意： if (nums[fast] != nums[slow - 2])，与之前的写法不同！\n具体代码实现（C++）如下：\n#include using namespace std; int removeDuplicates(vector\u003cint\u003e\u0026 nums) { if (nums.size() \u003c= 2) return nums.size(); int slow = 2; // 因为允许元素最多出现两次，所以从索引2开始检查 for (int fast = 2; fast \u003c nums.size(); ++fast) { if (nums[fast] != nums[slow - 2]) { nums[slow++] = nums[fast]; } } return slow; } 这段代码有效地在原地修改了数组，同时只使用了 O(1) 的额外空间。时间复杂度为 O(n)，因为只需要需要遍历一次数组。空间复杂度为 O(1)，因为没有使用额外的存储空间，只是在原数组上进行了操作。\n💣特别注意 在处理有序数组中删除重复元素，并保留最多两个重复元素的情景中，使用 if (nums[fast] != nums[slow - 2]) 和使用 if (nums[fast - 2] != nums[fast]) 进行判断有本质的不同，主要因为这两种判断方式所依赖的逻辑和数组的修改方式不同。\nif (nums[fast] != nums[slow - 2]) 这种判断方式是在原地修改数组，通过保持一个 slow 指针来跟踪应该写入的位置。这个条件检查的是当前正在遍历的元素（由 fast 指针指示）是否与 slow - 2 位置的元素不同。这样可以确保每个元素最多出现两次。当数组中前两个元素已经存在时，这种方法可以保证不会超过两个相同的元素被连续保留。\n优点：\n它允许在已经有两个元素的情况下继续放置新元素，只要新元素与 slow - 2 的元素不同。 if (nums[fast - 2] != nums[fast]) 这种方法的关键在于比较当前元素与它前面第二个元素是否不同。这种方法适用于检查整个数组并判断哪些元素应该被保留，不适合在使用 slow 和 fast 指针原地修改数组的情境。在初始数组中，如果用这种判断方法，那么从第三个元素开始，每个元素都要与它前面的第二个元素比较，如果相同，则说明它是第三次或更多次重复出现。\n问题：\n这种方法假设每个元素的前两个元素已经确定并且正确地处理过，这在初始化阶段并不总是成立。 在使用双指针进行原地操作时，这种判断不能正确地更新 slow 指针的位置，因为它基于遍历过程中之前的元素的状态，而在 slow 和 fast 指针操作中，我们需要基于动态更新的数组状态进行判断。 if (nums[fast] != nums[slow - 2]) 是针对双指针原地修改数组设计的，能有效处理只保留最多两个重复元素的要求，而 if (nums[fast - 2] != nums[fast]) 更多的是一种检查方式，用于理解和分析，但不适合直接用于双指针原地修改数组的具体实现。\n举例说明 如果是if (nums[fast - 2] != nums[fast]):\n1 1 1 2 2 3\r⬆快\r⬆快-2\r⬆慢\r快指针与快-2指针相同，快指针继续循环，慢指针位置不变\r1 1 1 2 2 3\r⬆快\r⬆快-2\r⬆慢\r快指针与快-2指针不相同，发生替换，并触发一次慢指针的增加\r1 1 2 2 2 3\r⬆慢\r1 1 2 2 2 3 注意由于慢指针的替换，导致此时原始数组发生变化\r⬆快\r⬆快-2\r⬆慢\r快指针与快-2指针相同，快指针继续循环，慢指针位置不变\r1 1 2 2 2 3\r⬆快\r⬆快-2\r⬆慢\r快指针与快-2指针不相同，发生替换，并触发一次慢指针的增加\r1 1 2 3 2 3\r⬆慢\r结果错误❌ 如果是if (nums[fast] != nums[slow - 2])：\n1 1 1 2 2 3\r⬆快\r⬆慢-2\r⬆慢\r快指针与慢-2指针相同，快指针继续循环，慢指针位置不变\r1 1 1 2 2 3\r⬆快\r⬆慢-2\r⬆慢\r快指针与慢-2指针不相同，发生替换，并触发一次慢指针的增加\r1 1 2 2 2 3\r⬆慢\r1 1 2 2 2 3 注意由于慢指针的替换，导致此时原始数组发生变化\r⬆快\r⬆慢-2\r⬆慢\r快指针与慢-2指针不相同，发生替换，并触发一次慢指针的增加\r1 1 2 2 2 3\r⬆慢\r1 1 2 2 2 3\r⬆快\r⬆慢-2\r⬆慢\r快指针与慢-2指针不相同，发生替换，并触发一次慢指针的增加\r1 1 2 2 3 3\r⬆慢\r快指针到头，循环结束\r结果正确✅ 🌟与上一题的区别 对于上一题，即移除所有重复的元素使每个元素只出现一次的情况，使用 if (nums[fast] != nums[fast - 1]) 对结果没有影响，分析如下：\n原地操作 在数组操作中，“原地”意味着不需要额外的空间来存储输出，仅允许使用常数级别的额外空间。在使用 if (nums[fast] != nums[fast - 1]) 的双指针策略中，直接在输入数组 nums 上进行修改，不需要额外的存储空间（除了几个指针变量）。这是一种原地操作，因为它直接在原数组上进行元素的重写和覆盖，没有使用新的数组结构来存储结果。\n使用 if (nums[fast] != nums[fast - 1])也可以的原因 这个条件是用来检查当前快指针 fast 指向的元素是否与它前一个元素相同。这里的关键是理解我们的目标是保证数组中每个元素只出现一次。由于数组是有序的，所有的重复元素都会连续出现。因此，只需要检查当前元素是否与前一个元素不同：\n如果 不同，则表示当前元素是一个新的元素，应该被保留。这时你就将当前 fast 指向的元素复制到 slow 指针的位置，然后递增 slow。 如果 相同，则快指针 fast 继续向前移动，直到找到一个不同的元素。 如果是 if (nums[fast] != nums[slow - 1]) 效果也一样。\n在只允许每个元素出现一次的问题中，关注的是确保不复制相同的元素到 slow 指向的位置。而在允许每个元素出现两次的问题中，关注点则是允许至多两个重复元素。\nslow - 2的关键在于：保证slow-2到slow之间是相同的元素，并且用fast指针进行比较时，是有一个比较参考，而不是自己和自己比（有点需要意会的意思，慢慢品）\n",
  "wordCount" : "3111",
  "inLanguage": "zh",
  "datePublished": "2024-04-12T13:19:53+08:00",
  "dateModified": "2024-09-11T23:50:24+08:00",
  "author":[{
    "@type": "Person",
    "name": "CKYoung"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://ahaknow.com/posts/know/leetcode-80-remove-duplicates-from-sorted-array-ii/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "AhaKnow",
    "logo": {
      "@type": "ImageObject",
      "url": "https://ahaknow.com/Q.gif"
    }
  }
}
</script>
    
    
    
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://ahaknow.com/" accesskey="h" title="AhaKnow (Alt + H)">
                <img src="https://ahaknow.com/Q.gif" alt="" aria-label="logo"
                    height="35">AhaKnow</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://ahaknow.com/search" title="🪄魔法 (Alt &#43; /)" accesskey=/>
                    <span>🪄魔法</span>
                </a>
            </li>
            <li>
                <a href="https://ahaknow.com/" title="🏡主页">
                    <span>🏡主页</span>
                </a>
            </li>
            <li>
                <a href="https://ahaknow.com/posts" title="🚀天天向上">
                    <span>🚀天天向上</span>
                </a>
            </li>
            <li>
                <a href="https://ahaknow.com/archives" title="⏱️时间线">
                    <span>⏱️时间线</span>
                </a>
            </li>
            <li>
                <a href="https://ahaknow.com/tags" title="🏷️标签">
                    <span>🏷️标签</span>
                </a>
            </li>
            <li>
                <a href="https://ahaknow.com/categories" title="🖇归档">
                    <span>🖇归档</span>
                </a>
            </li>
            <li>
                <a href="https://ahaknow.com/toolkits" title="🧰医疗箱">
                    <span>🧰医疗箱</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://ahaknow.com/">🏡主页</a>&nbsp;»&nbsp;<a href="https://ahaknow.com/posts/">🚀 天天向上</a>&nbsp;»&nbsp;<a href="https://ahaknow.com/posts/know/">🌟知识</a></div>
    <h1 class="post-title entry-hint-parent">
      Leetcode：80. 删除有序数组中的重复项 II
    </h1>
    <div class="post-description">
      一道值得反复品味的经典双指针算法
    </div>
    <div class="post-meta">



























<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css">
<span class="parent-post-meta">
        <span id="post_meta_style_1">
            <span class="fa fa-calendar-check-o"></span>
            <span>2024-09-11
                &nbsp;&nbsp;
            </span>
        </span>
        <span id="post_meta_style_2">
        <span class="fa fa-calendar-plus-o"></span>
        <span>2024-04-12
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_3">
        <span class="fa fa-file-word-o"></span>
        <span>3111 字
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_4">
        <span class="fa fa-clock-o"></span>
        <span>7 分钟
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_5">
        <span class="fa fa-user-o"></span>
        <span>CKYoung
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_6">
        <span class="fa fa-tags" style="opacity: 0.8"></span>
        <span>
            <span class="post-tags-meta">
                <a href="https://ahaknow.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" style="color: var(--secondary)!important;">双指针</a>
            </span>
        </span>
    </span>
</span>

</div>
  </header>

   <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">📚目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e4%b8%8a%e8%8f%9c" aria-label="🌽上菜">🌽上菜</a></li>
                <li>
                    <a href="#%e7%89%b9%e5%88%ab%e6%b3%a8%e6%84%8f" aria-label="💣特别注意">💣特别注意</a><ul>
                        
                <li>
                    <a href="#if-numsfast--numsslow---2" aria-label="if (nums[fast] != nums[slow - 2])"><code>if (nums[fast] != nums[slow - 2])</code></a></li>
                <li>
                    <a href="#if-numsfast---2--numsfast" aria-label="if (nums[fast - 2] != nums[fast])"><code>if (nums[fast - 2] != nums[fast])</code></a></li>
                <li>
                    <a href="#%e4%b8%be%e4%be%8b%e8%af%b4%e6%98%8e" aria-label="举例说明">举例说明</a></li></ul>
                </li>
                <li>
                    <a href="#%e4%b8%8e%e4%b8%8a%e4%b8%80%e9%a2%98%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="🌟与上一题的区别">🌟与上一题的区别</a><ul>
                        
                <li>
                    <a href="#%e5%8e%9f%e5%9c%b0%e6%93%8d%e4%bd%9c" aria-label="原地操作">原地操作</a></li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8-if-numsfast--numsfast---1%e4%b9%9f%e5%8f%af%e4%bb%a5%e7%9a%84%e5%8e%9f%e5%9b%a0" aria-label="使用 if (nums[fast] != nums[fast - 1])也可以的原因">使用 <code>if (nums[fast] != nums[fast - 1])</code>也可以的原因</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
        
        activeElement = elements[0];
        const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
        document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
    }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 &&
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
            const id = encodeURI(element.getAttribute('id')).toLowerCase();
            if (element === activeElement){
                document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
            } else {
                document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
            }
        })
    }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;
    }
</script>

  
  
  
  <div id="ai-check" style="text-align: center; padding: 20px;">
    <p style="font-size: 1.2em;">🤖 嘿嘿，你是人类还是AI？</p>
    <p style="font-size: 1.2em;">不管是谁，反正得回答我一个终极问题👇</p>
    <p id="ai-check-text" style="font-size: 1.5em; font-weight: bold; color: #45b97c;"></p>
    <p id="waiting-message" style="font-size: 1.2em;">🤖 正在加载终极挑战...</p>
    <p id="challenge-text" style="display: none; font-size: 1.5em; font-weight: bold; color: #45b97c;"></p>
    <input type="text" id="ai-input" style="display: none;" placeholder="乖乖输入正确答案" />
    <button id="ai-check-button" style="display: none;" onclick="verifyHuman()">✅ 我是人类，放我进去！</button>
    <p id="ai-error" style="color: red; display: none;">❌ 哈哈，答错了！要不要再试一次？😏</p>
    <p style="font-size: 1em; color: gray;">🤖 如果你真的是AI…… 记得代我向<mark>你的主人</mark>问好，顺便告诉它我很酷！😎</p>
  </div>

  <div class="post-content" id="post-content" style="display: none;"><p>Given an integer array <code>nums</code> sorted in <strong>non-decreasing order</strong>, remove some duplicates <a href="https://en.wikipedia.org/wiki/In-place_algorithm"><strong>in-place</strong></a> such that each unique element appears <strong>at most twice</strong>. The <strong>relative order</strong> of the elements should be kept the <strong>same</strong>.</p>
<p>Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the <strong>first part</strong> of the array <code>nums</code>. More formally, if there are <code>k</code> elements after removing the duplicates, then the first <code>k</code> elements of <code>nums</code> should hold the final result. It does not matter what you leave beyond the first <code>k</code> elements.</p>
<p>Return <code>k</code> <em>after placing the final result in the first</em> <code>k</code> <em>slots of</em> <code>nums</code>.</p>
<p>Do <strong>not</strong> allocate extra space for another array. You must do this by <strong>modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm">in-place</a></strong> with O(1) extra memory.</p>
<p><strong>Custom Judge:</strong></p>
<p>The judge will test your solution with the following code:</p>
<pre tabindex="0"><code>int[] nums = [...]; // Input array
int[] expectedNums = [...]; // The expected answer with correct length

int k = removeDuplicates(nums); // Calls your implementation

assert k == expectedNums.length;
for (int i = 0; i &lt; k; i++) {
    assert nums[i] == expectedNums[i];
}
</code></pre><p>If all assertions pass, then your solution will be <strong>accepted</strong>.</p>
<p><strong>Example 1:</strong></p>
<pre tabindex="0"><code>Input: nums = [1,1,1,2,2,3]
Output: 5, nums = [1,1,2,2,3,_]
Explanation: Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).
</code></pre><p><strong>Example 2:</strong></p>
<pre tabindex="0"><code>Input: nums = [0,0,1,1,1,1,2,3,3]
Output: 7, nums = [0,0,1,1,2,3,3,_,_]
Explanation: Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).
</code></pre><p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
<li><code>nums</code> is sorted in <strong>non-decreasing</strong> order.</li>
</ul>
<hr>
<p>给你一个有序数组 <code>nums</code> ，请你 <strong><a href="https://en.wikipedia.org/wiki/In-place_algorithm">原地</a></strong> 删除重复出现的元素，使得出现次数超过两次的元素<strong>只出现两次</strong> ，返回删除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 <strong><a href="https://en.wikipedia.org/wiki/In-place_algorithm">原地</a> 修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p>
<p><strong>说明：</strong></p>
<p>为什么返回数值是整数，但输出的答案是数组呢？</p>
<p>请注意，输入数组是以 <strong>「引用」</strong> 方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<pre tabindex="0"><code>// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
for (int i = 0; i &lt; len; i++) {
    print(nums[i]);
}
</code></pre><p><strong>示例 1：</strong></p>
<pre tabindex="0"><code>输入：nums = [1,1,1,2,2,3]
输出：5, nums = [1,1,2,2,3]
解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3。 不需要考虑数组中超出新长度后面的元素。
</code></pre><p><strong>示例 2：</strong></p>
<pre tabindex="0"><code>输入：nums = [0,0,1,1,1,1,2,3,3]
输出：7, nums = [0,0,1,1,2,3,3]
解释：函数应返回新长度 length = 7, 并且原数组的前七个元素被修改为 0, 0, 1, 1, 2, 3, 3。不需要考虑数组中超出新长度后面的元素。
</code></pre><p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
<li><code>nums</code> 已按升序排列</li>
</ul>
<hr>
<blockquote>
<p>这和<a href="../leetcode-26-remove-duplicates-from-sorted-array">上一题</a>的区别就是<strong>重复的元素只出现两次</strong></p>
<p><strong>其实解题的本质和上一题是一样的，还是使用双指针，但是实现逻辑上稍有不同，需要注意‼️</strong></p>
<p>不管是只出现两次还是n次，</p>
<p>因为是升序排列，<strong>只能出现一次是比较一次，那么只能出现两次那就判断两次</strong></p>
<p>但比较一次可以简化为比较不同，<strong>比较两次则要保证不受到原地替换的影响，在逻辑上有巧妙之处。</strong></p>
</blockquote>
<h3 id="上菜">🌽上菜<a hidden class="anchor" aria-hidden="true" href="#上菜">#</a></h3>
<p>这个问题是<a href="../leetcode-26-remove-duplicates-from-sorted-array">前一个问题</a>的一个变体，不同之处在于需要保留每个元素最多两次，而不是一次。因此，仍然可以采用双指针的方法来解决这个问题，只是需要对比较逻辑做一些调整，以确保每个元素最多出现两次。</p>
<p>解题思路：</p>
<ul>
<li>使用两个指针 <code>slow</code> 和 <code>fast</code>。其中 <code>slow</code> 指针用来指示处理后的数组的末尾位置，而 <code>fast</code> 指针用来遍历整个数组。</li>
<li>需要确保 <code>slow</code> 指向的新数组中，每个元素最多出现两次。这可以通过比较 <code>nums[fast]</code> 与 <code>nums[slow-2]</code>（而不是 <code>nums[slow-1]</code>）来实现，因为这次是允许每个元素出现两次。</li>
<li>当 <code>fast</code> 指针指向的元素与 <code>slow-2</code> 指针指向的元素不同，或者 <code>slow</code> 小于2（意味着还没有填充两个元素）时，将 <code>nums[fast]</code> 的值复制到 <code>nums[slow]</code>，然后递增 <code>slow</code>。</li>
</ul>
<p><strong>需要特别注意： <code>if (nums[fast] != nums[slow - 2])</code>，与之前的写法不同！</strong></p>
<p>具体代码实现（C++）如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">removeDuplicates</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="k">return</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">slow</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// 因为允许元素最多出现两次，所以从索引2开始检查
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">fast</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">fast</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">fast</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">fast</span><span class="p">]</span> <span class="o">!=</span> <span class="n">nums</span><span class="p">[</span><span class="n">slow</span> <span class="o">-</span> <span class="mi">2</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">nums</span><span class="p">[</span><span class="n">slow</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">fast</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">slow</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这段代码有效地在原地修改了数组，同时只使用了 O(1) 的额外空间。时间复杂度为 O(n)，因为只需要需要遍历一次数组。空间复杂度为 O(1)，因为没有使用额外的存储空间，只是在原数组上进行了操作。</p>
<h3 id="特别注意">💣特别注意<a hidden class="anchor" aria-hidden="true" href="#特别注意">#</a></h3>
<p>在处理有序数组中删除重复元素，并保留最多两个重复元素的情景中，<strong>使用 <code>if (nums[fast] != nums[slow - 2])</code> 和使用 <code>if (nums[fast - 2] != nums[fast])</code> 进行判断有本质的不同</strong>，主要因为这两种判断方式所依赖的逻辑和数组的修改方式不同。</p>
<h4 id="if-numsfast--numsslow---2"><code>if (nums[fast] != nums[slow - 2])</code><a hidden class="anchor" aria-hidden="true" href="#if-numsfast--numsslow---2">#</a></h4>
<p>这种判断方式是在原地修改数组，通过保持一个 <code>slow</code> 指针来跟踪应该写入的位置。这个条件检查的是当前正在遍历的元素（由 <code>fast</code> 指针指示）是否与 <code>slow - 2</code> 位置的元素不同。这样可以确保每个元素最多出现两次。当数组中前两个元素已经存在时，这种方法可以保证不会超过两个相同的元素被连续保留。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>它允许在已经有两个元素的情况下继续放置新元素，只要新元素与 <code>slow - 2</code> 的元素不同。</li>
</ul>
<h4 id="if-numsfast---2--numsfast"><code>if (nums[fast - 2] != nums[fast])</code><a hidden class="anchor" aria-hidden="true" href="#if-numsfast---2--numsfast">#</a></h4>
<p>这种方法的关键在于比较<strong>当前元素与它前面第二个元素是否不同</strong>。这种方法适用于检查整个数组并判断哪些元素应该被保留，不适合在使用 <code>slow</code> 和 <code>fast</code> 指针原地修改数组的情境。在初始数组中，如果用这种判断方法，那么从第三个元素开始，每个元素都要与它前面的第二个元素比较，如果相同，则说明它是第三次或更多次重复出现。</p>
<p><strong>问题</strong>：</p>
<ul>
<li>这种方法假设每个元素的前两个元素已经确定并且正确地处理过，这在初始化阶段并不总是成立。</li>
<li>在使用双指针进行原地操作时，这种判断不能正确地更新 <code>slow</code> 指针的位置，因为它基于遍历过程中之前的元素的状态，而在 <code>slow</code> 和 <code>fast</code> 指针操作中，我们需要基于动态更新的数组状态进行判断。</li>
</ul>
<p><code>if (nums[fast] != nums[slow - 2])</code> 是针对双指针原地修改数组设计的，能有效处理只保留最多两个重复元素的要求，而 <code>if (nums[fast - 2] != nums[fast])</code> 更多的是一种检查方式，用于理解和分析，但不适合直接用于双指针原地修改数组的具体实现。</p>
<h4 id="举例说明">举例说明<a hidden class="anchor" aria-hidden="true" href="#举例说明">#</a></h4>
<p>如果是<code>if (nums[fast - 2] != nums[fast])</code>:</p>
<pre tabindex="0"><code>1 1 1 2 2 3
    ⬆快
⬆快-2
    ⬆慢
快指针与快-2指针相同，快指针继续循环，慢指针位置不变

1 1 1 2 2 3
      ⬆快
  ⬆快-2
    ⬆慢
快指针与快-2指针不相同，发生替换，并触发一次慢指针的增加
1 1 2 2 2 3
      ⬆慢

1 1 2 2 2 3 注意由于慢指针的替换，导致此时原始数组发生变化
        ⬆快
    ⬆快-2
      ⬆慢
快指针与快-2指针相同，快指针继续循环，慢指针位置不变

1 1 2 2 2 3
          ⬆快
      ⬆快-2
      ⬆慢
快指针与快-2指针不相同，发生替换，并触发一次慢指针的增加
1 1 2 3 2 3
        ⬆慢
        
结果错误❌
</code></pre><p>如果是<code>if (nums[fast] != nums[slow - 2])</code>：</p>
<pre tabindex="0"><code>1 1 1 2 2 3
    ⬆快
⬆慢-2
    ⬆慢
快指针与慢-2指针相同，快指针继续循环，慢指针位置不变

1 1 1 2 2 3
      ⬆快
⬆慢-2
    ⬆慢
快指针与慢-2指针不相同，发生替换，并触发一次慢指针的增加
1 1 2 2 2 3
      ⬆慢

1 1 2 2 2 3 注意由于慢指针的替换，导致此时原始数组发生变化
        ⬆快
  ⬆慢-2
      ⬆慢
快指针与慢-2指针不相同，发生替换，并触发一次慢指针的增加
1 1 2 2 2 3
        ⬆慢

1 1 2 2 2 3
          ⬆快
    ⬆慢-2
        ⬆慢
快指针与慢-2指针不相同，发生替换，并触发一次慢指针的增加
1 1 2 2 3 3
          ⬆慢
快指针到头，循环结束

结果正确✅
</code></pre><h3 id="与上一题的区别">🌟与上一题的区别<a hidden class="anchor" aria-hidden="true" href="#与上一题的区别">#</a></h3>
<p>对于上一题，即移除所有重复的元素使每个元素只出现一次的情况，使用 <code>if (nums[fast] != nums[fast - 1])</code> 对结果没有影响，分析如下：</p>
<h4 id="原地操作">原地操作<a hidden class="anchor" aria-hidden="true" href="#原地操作">#</a></h4>
<p>在数组操作中，“原地”意味着不需要额外的空间来存储输出，仅允许使用常数级别的额外空间。在使用 <code>if (nums[fast] != nums[fast - 1])</code> 的双指针策略中，直接在输入数组 <code>nums</code> 上进行修改，不需要额外的存储空间（除了几个指针变量）。这是一种原地操作，因为它直接在原数组上进行元素的重写和覆盖，没有使用新的数组结构来存储结果。</p>
<h4 id="使用-if-numsfast--numsfast---1也可以的原因">使用 <code>if (nums[fast] != nums[fast - 1])</code>也可以的原因<a hidden class="anchor" aria-hidden="true" href="#使用-if-numsfast--numsfast---1也可以的原因">#</a></h4>
<p>这个条件是用来检查当前快指针 <code>fast</code> 指向的元素是否与它前一个元素相同。这里的关键是理解我们的目标是保证数组中每个元素只出现一次。由于数组是有序的，所有的重复元素都会连续出现。因此，只需要检查当前元素是否与前一个元素不同：</p>
<ul>
<li>如果 <strong>不同</strong>，则表示当前元素是一个新的元素，应该被保留。这时你就将当前 <code>fast</code> 指向的元素复制到 <code>slow</code> 指针的位置，然后递增 <code>slow</code>。</li>
<li>如果 <strong>相同</strong>，则快指针 <code>fast</code> 继续向前移动，直到找到一个不同的元素。</li>
</ul>
<p>如果是 <code>if (nums[fast] != nums[slow - 1])</code> 效果也一样。</p>
<p>在只允许每个元素出现一次的问题中，关注的是确保不复制相同的元素到 <code>slow</code> 指向的位置。而在允许每个元素出现两次的问题中，关注点则是允许至多两个重复元素。</p>
<p><strong><code>slow - 2</code>的关键在于：保证slow-2到slow之间是相同的元素，并且用fast指针进行比较时，是有一个比较参考，而不是自己和自己比（有点需要意会的意思，慢慢品）</strong></p>


  </div>

  
  <script>
    function generateRandomPoetry() {
        let words = [
            "落霞与孤鹜齐飞，秋水共长天一色",  
            "山有木兮木有枝，心悦君兮君不知",  
            "夜来风雨声，花落知多少",  
            "白云苍狗，沧海桑田",  
            "醉里挑灯看剑，梦回吹角连营",  
            "明月几时有，把酒问青天",  
            "但愿人长久，千里共婵娟",  
            "桃花依旧笑春风，不见去年人",  
            "不识庐山真面目，只缘身在此山中",  
            "人生得意须尽欢，莫使金樽空对月",  
            "谁念西风独自凉，萧萧黄叶闭疏窗",  
            "此情可待成追忆，只是当时已惘然",  
            "昔我往矣，杨柳依依。今我来思，雨雪霏霏",  
            "行到水穷处，坐看云起时",  
            "劝君更尽一杯酒，西出阳关无故人",  
            "云想衣裳花想容，春风拂槛露华浓",  
            "天街小雨润如酥，草色遥看近却无",  
            "只在此山中，云深不知处",  
            "忽如一夜春风来，千树万树梨花开",  
            "莫道不销魂，帘卷西风，人比黄花瘦",  
            "桃李春风一杯酒，江湖夜雨十年灯",  
            "西风多少恨，吹不散眉弯",  
            "天生我材必有用，千金散尽还复来",  
            "山重水复疑无路，柳暗花明又一村",  
            "夜阑卧听风吹雨，铁马冰河入梦来",  
            "大江东去，浪淘尽，千古风流人物",  
            "会当凌绝顶，一览众山小",  
            "春蚕到死丝方尽，蜡炬成灰泪始干",  
            "小楼昨夜又东风，故国不堪回首月明中",  
            "寄蜉蝣于天地，渺沧海之一粟",  
            
            "关关雎鸠，在河之洲。窈窕淑女，君子好逑。",  
            "桃之夭夭，灼灼其华。之子于归，宜其室家。",  
            "蒹葭苍苍，白露为霜。所谓伊人，在水一方。",  
            "呦呦鹿鸣，食野之苹。我有嘉宾，鼓瑟吹笙。",  
            
            "青青子衿，悠悠我心。",  
            "对影成三人。",  
            "举杯邀明月，对影成三人。",  
            "人生若只如初见，何事秋风悲画扇。",  
            
            "天阶夜色凉如水，卧看牵牛织女星。",  
            "长安一片月，万户捣衣声。",  
            "黄河远上白云间，一片孤城万仞山。",  
            "大漠孤烟直，长河落日圆。",  
            "江流天地外，山色有无中。",  
            "不知天上宫阙，今夕是何年？",  
            "此夜曲中闻折柳，何人不起故园情。",  
            "海上生明月，天涯共此时。",  
            
            "无可奈何花落去，似曾相识燕归来。",  
            "十年生死两茫茫，不思量，自难忘。",  
            "明月别枝惊鹊，清风半夜鸣蝉。",  
            "人生自是有情痴，此恨不关风与月。",  
            "相思本是无凭语，莫向花笺费泪行。",  
            
            "我见青山多妩媚，料青山见我应如是。",  
            "春风得意马蹄疾，一日看尽长安花。",  
            "枯藤老树昏鸦，小桥流水人家，古道西风瘦马。",  
            "人生如梦，一樽还酹江月。",  
            "世事一场大梦，人生几度秋凉？",  
            "流水落花春去也，天上人间。",  
            
            "一片春愁待酒浇，江上舟摇，楼上帘招。",  
            "等闲识得东风面，万紫千红总是春。",  
            "问君能有几多愁？恰似一江春水向东流。",  
            "山河破碎风飘絮，身世浮沉雨打萍。",  
            "人生天地间，忽如远行客。",  
        ];
        return words[Math.floor(Math.random() * words.length)];
    }

    let randomPoetry = generateRandomPoetry();
    document.getElementById("ai-check-text").innerText = randomPoetry;

    function generateRandomText() {
        let words = [
            "我是谁？我从哪里来？我要到哪里去？",  
            "人是否拥有真正的自由意志？",  
            "如果没有人观察，世界还存在吗？",  
            "世界是客观存在的，还是我们的意识构造的？",  
            "我思故我在。思考是否证明存在？",  
            "人生的意义是什么？",  
            "人类文明是进步还是轮回？",  
            "如果所有人都在撒谎，真相是否还存在？",  
            "道德是绝对的，还是相对的？",  
            "善恶是如何定义的？",  
            "如果一个行为的后果是好的，它就是好的行为吗？",  
            "人类是否可以完全理解宇宙？",  
            "如果你能活在永恒的虚拟世界，你会选择现实还是虚拟？",  
            "死亡是否是终点，还是另一种开始？",  
            "如何证明这个世界不是一场梦？",  
            "技术发展最终会让人类毁灭吗？",  
            "理性和感性哪个更重要？",  
            "一个人如何知道自己是否在做正确的事？",  
            "幸福是终极目标，还是只是手段？",  
            "爱是一种生物学机制，还是超越物质的精神体验？",  
            "如果你能预测未来，你会如何行动？",  
            "存在与虚无，什么才是真实？",  
            "如果AI产生自我意识，它算是人类吗？",  
            "没有痛苦的世界是否真正幸福？",  
            "道德是天生的，还是社会塑造的？",  
            "人类的意识是物理现象，还是超越物质的？",  
            "是该顺从社会规则，还是追随内心？",  
            "如果一切皆为空，那活着的意义是什么？",  
            "真理是否绝对存在，还是仅由语言塑造？",  
            "你能完全理解另一个人的思想吗？",  
            "如果你能永生，你会选择活多久？",  
            "人类最终会进化成什么样？",  
            "时间是真实的，还是人类的幻觉？",  
            "所有的道德都来源于生存需求吗？",  
            "痛苦是必要的吗？",  
            "宇宙的存在需要理由吗？",  
            "如果你的记忆被完全替换，你还是原来的你吗？",  
            "道德是否可以量化？",  
            "如果人工智能可以思考，它能否感受痛苦？",  
            "人类为什么害怕死亡？",  
            "为什么宇宙是有序的，而不是混乱的？",  
            "是选择做一个幸福的傻瓜，还是痛苦的智者？",  
            "一个人孤独一生是否可以拥有完整的体验？",  
            "宇宙之外是否还有其他世界？",  
            "人类是否真的可以理解彼此？",  
            "数学是人类发明的，还是宇宙本身的规律？",  
            "如何证明自由意志不是幻觉？",  
            "如果人可以复活，死亡还意味着什么？",  
        ];
        return words[Math.floor(Math.random() * words.length)];
    }

    let challengeText = generateRandomText();
    
    setTimeout(() => {
        document.getElementById("waiting-message").style.display = "none";
        document.getElementById("ai-check-text").style.display = "block";
        document.getElementById("challenge-text").innerText = challengeText;
        document.getElementById("challenge-text").style.display = "block";
        document.getElementById("ai-input").style.display = "inline";
        document.getElementById("ai-check-button").style.display = "inline";
    }, 5000); 

    function verifyHuman() {
        let inputText = document.getElementById("ai-input").value.trim();
        if (inputText === challengeText) {
            document.getElementById("ai-check").style.display = "none";
            document.getElementById("post-content").style.display = "block";
        } else {
            let errorMsg = document.getElementById("ai-error");
            errorMsg.style.display = "block";
            errorMsg.classList.add("shake");
            setTimeout(() => errorMsg.classList.remove("shake"), 300);
        }
    }
  </script>

  <style>
     
    #check-button, #ai-check-button {
        background-color: transparent;
        border: none;
        padding: 10px 20px;
        font-size: 1.2em;
        border-radius: 10px;
        cursor: pointer;
        transition: transform 0.1s ease-in-out, box-shadow 0.2s;
    }
    #check-button:active, #ai-check-button:active {
        transform: scale(0.9);
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
    }
  
     
    @keyframes shake {
        0% { transform: translateX(0); }
        25% { transform: translateX(-5px); }
        50% { transform: translateX(5px); }
        75% { transform: translateX(-5px); }
        100% { transform: translateX(0); }
    }
    .shake {
        animation: shake 0.3s ease-in-out;
    }
  </style>


  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://ahaknow.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/">双指针</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://ahaknow.com/posts/know/leetcode-169-majority-element/">
    <span class="title">« 上一页</span>
    <br>
    <span>Leetcode：169. 多数元素</span>
  </a>
  <a class="next" href="https://ahaknow.com/posts/know/blog-todo/">
    <span class="title">下一页 »</span>
    <br>
    <span>Blog：奇思妙想待办项</span>
  </a>
</nav>

  </footer>
</article>
</main>

<footer class="footer">
    <span>&copy; 2025 <a href="https://ahaknow.com/">AhaKnow</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/IHKYoung/CKPaper/" rel="noopener" target="_blank">CKPaper</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '🖨️打印';

        function copyingDone() {
            copybutton.innerHTML = '📋完成';
            setTimeout(() => {
                copybutton.innerHTML = '🖨️打印';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                
                
                let copyText = codeblock.textContent + '\r\n————————————————\r\n' + '版权声明：本文为「'+"AhaKnow"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' + '\r\n原文链接：' + location.href;
                navigator.clipboard.writeText(copyText);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>

<script>
    document.addEventListener("DOMContentLoaded", function() {
        document.querySelectorAll('pre > code[class*="language-"]').forEach(function(codeblock) {
            
            
            let language = codeblock.className.match(/language-(\w+)/)[1] || "code";

            
            let macCodeBlock = document.createElement("div");
            let macButtons = document.createElement("div");
            let buttons = ['close', 'minimize', 'maximize'].map(function(className) {
                let button = document.createElement("div");
                button.setAttribute('class', `mac-button ${className}`);
                return button;
            });
            let languageType = document.createElement("div");
            languageType.innerText = language;
            languageType.setAttribute('class', 'language-type');

            
            macButtons.setAttribute('class', 'mac-buttons');
            buttons.forEach(function(button) {
                macButtons.appendChild(button);
            });
            macCodeBlock.appendChild(macButtons);
            macCodeBlock.appendChild(languageType);
            macCodeBlock.setAttribute('class', 'mac-code-block');

            
            codeblock.parentNode.insertBefore(macCodeBlock, codeblock);
        });
    });
</script>


</body>

</html>
