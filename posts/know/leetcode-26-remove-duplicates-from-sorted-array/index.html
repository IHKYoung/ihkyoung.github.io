<!DOCTYPE html>














<script>
    MathJax = {
        tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$'], ['\\[', '\\]']],
            processEscapes: true,
            processEnvironments: true
        },
        options: {
            skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        }
    };

    window.addEventListener('load', (event) => {
        document.querySelectorAll("mjx-container").forEach(function (x) {
            x.parentElement.classList += 'has-jax'
        })
    });
</script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>



<html lang="zh" dir="zh-cn">
<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Leetcode：26删除有序数组中的重复项 | AhaKnow</title>
<meta name="keywords" content="双指针">
<meta name="description" content="Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums.
Consider the number of unique elements of nums to be k, to get accepted, you need to do the following things:

Change the array nums such that the first k elements of nums contain the unique elements in the order they were present in nums initially. The remaining elements of nums are not important as well as the size of nums.
Return k.

Custom Judge:">
<meta name="author" content="CKYoung">
<link rel="canonical" href="https://ahaknow.com/posts/know/leetcode-26-remove-duplicates-from-sorted-array/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="https://ahaknow.com/Q.gif">
<link rel="icon" type="image/png" sizes="16x16" href="https://ahaknow.com/Q.gif">
<link rel="icon" type="image/png" sizes="32x32" href="https://ahaknow.com/Q.gif">
<link rel="apple-touch-icon" href="https://ahaknow.com/Q.gif">
<link rel="mask-icon" href="https://ahaknow.com/Q.gif">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://ahaknow.com/posts/know/leetcode-26-remove-duplicates-from-sorted-array/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Leetcode：26删除有序数组中的重复项" />
<meta property="og:description" content="Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums.
Consider the number of unique elements of nums to be k, to get accepted, you need to do the following things:

Change the array nums such that the first k elements of nums contain the unique elements in the order they were present in nums initially. The remaining elements of nums are not important as well as the size of nums.
Return k.

Custom Judge:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ahaknow.com/posts/know/leetcode-26-remove-duplicates-from-sorted-array/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-04-11T11:41:10+08:00" />
<meta property="article:modified_time" content="2024-09-11T23:50:24+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Leetcode：26删除有序数组中的重复项"/>
<meta name="twitter:description" content="Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums.
Consider the number of unique elements of nums to be k, to get accepted, you need to do the following things:

Change the array nums such that the first k elements of nums contain the unique elements in the order they were present in nums initially. The remaining elements of nums are not important as well as the size of nums.
Return k.

Custom Judge:"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "🚀 天天向上",
      "item": "https://ahaknow.com/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "🌟知识",
      "item": "https://ahaknow.com/posts/know/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Leetcode：26删除有序数组中的重复项",
      "item": "https://ahaknow.com/posts/know/leetcode-26-remove-duplicates-from-sorted-array/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Leetcode：26删除有序数组中的重复项",
  "name": "Leetcode：26删除有序数组中的重复项",
  "description": "Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums.\nConsider the number of unique elements of nums to be k, to get accepted, you need to do the following things:\nChange the array nums such that the first k elements of nums contain the unique elements in the order they were present in nums initially. The remaining elements of nums are not important as well as the size of nums. Return k. Custom Judge:\n",
  "keywords": [
    "双指针"
  ],
  "articleBody": "Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums.\nConsider the number of unique elements of nums to be k, to get accepted, you need to do the following things:\nChange the array nums such that the first k elements of nums contain the unique elements in the order they were present in nums initially. The remaining elements of nums are not important as well as the size of nums. Return k. Custom Judge:\nThe judge will test your solution with the following code:\nint[] nums = [...]; // Input array\rint[] expectedNums = [...]; // The expected answer with correct length\rint k = removeDuplicates(nums); // Calls your implementation\rassert k == expectedNums.length;\rfor (int i = 0; i \u003c k; i++) {\rassert nums[i] == expectedNums[i];\r} If all assertions pass, then your solution will be accepted.\nExample 1:\nInput: nums = [1,1,2]\rOutput: 2, nums = [1,2,_]\rExplanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.\rIt does not matter what you leave beyond the returned k (hence they are underscores). Example 2:\nInput: nums = [0,0,1,1,1,2,2,3,3,4]\rOutput: 5, nums = [0,1,2,3,4,_,_,_,_,_]\rExplanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.\rIt does not matter what you leave beyond the returned k (hence they are underscores). Constraints:\n1 \u003c= nums.length \u003c= 3 * 104 -100 \u003c= nums[i] \u003c= 100 nums is sorted in non-decreasing order. 给你一个 非严格递增排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。\n考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过：\n更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。 返回 k 。 判题标准:\n系统会用下面的代码来测试你的题解:\nint[] nums = [...]; // 输入数组\rint[] expectedNums = [...]; // 长度正确的期望答案\rint k = removeDuplicates(nums); // 调用\rassert k == expectedNums.length;\rfor (int i = 0; i \u003c k; i++) {\rassert nums[i] == expectedNums[i];\r} 如果所有断言都通过，那么您的题解将被 通过。\n示例 1：\n输入：nums = [1,1,2]\r输出：2, nums = [1,2,_]\r解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。 示例 2：\n输入：nums = [0,0,1,1,1,2,2,3,3,4]\r输出：5, nums = [0,1,2,3,4]\r解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。 提示：\n1 \u003c= nums.length \u003c= 3 * 104 -104 \u003c= nums[i] \u003c= 104 nums 已按 非严格递增 排列 “非严格递增”的意思是指：序列已经按照从小到大排序了，只不过有些元素重复了，所以是非严格递增；\n有序数列的问题，还是用双指针，只不过指针的用处稍微不同。\n快指针用来判断前后元素是否相同，慢指针用来按照需求保留。\n🥬上菜 这个问题可以使用类似于LeetCode26的解决方案，即使用双指针法。这次也是使用快慢指针，但是有一点不同：当快指针指向的元素与慢指针指向的元素相同时，只移动快指针，以跳过重复的元素；当快慢指针指向的元素不同，将快指针的元素复制到慢指针的下一个位置，然后同时移动快慢指针。\n这样处理后，数组的前 k 个元素就是唯一的元素，并且保持了它们最初的相对顺序，其中 k 是返回的数组长度。\n下面是具体步骤：\n如果数组的长度 n 小于等于1，则直接返回 n（因为没有重复元素需要删除）。 初始化两个指针 slow = 1 和 fast = 1。 当 fast 小于数组长度时，比较 nums[fast] 和 nums[fast - 1]： 如果 nums[fast] 不等于 nums[fast - 1]，说明遇到了一个新的元素，就将 nums[fast] 的值复制到 nums[slow]，然后 slow 增加1。 否则，快指针 fast 继续前进，直到找到一个不同的元素。 当数组遍历完成后，slow 指针的位置就是新数组的长度。 下面是用C++实现的代码示例：\n// 26. Remove Duplicates from Sorted Array #include #include using namespace std; class Solution { public: int removeDuplicates(vector\u003cint\u003e\u0026 nums) { if (nums.size() \u003c= 1) return nums.size(); int slow = 1; for (int fast = 1; fast \u003c nums.size(); fast++) { if (nums[fast - 1] != nums[fast]) { nums[slow++] = nums[fast]; } } return slow; } }; // 这道题也可以直接使用vector的earse()和unique() // nums.erase(unique(nums.begin(), nums.end()), nums.end()); 这段代码通过双指针法高效地实现了原地删除数组中的重复项，且只使用了 O(1) 的额外空间。由于 nums 是非严格递增排列的，可以确保所有的重复项都是连续出现的，这让问题变得更加简单。\n",
  "wordCount" : "1390",
  "inLanguage": "zh",
  "datePublished": "2024-04-11T11:41:10+08:00",
  "dateModified": "2024-09-11T23:50:24+08:00",
  "author":[{
    "@type": "Person",
    "name": "CKYoung"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://ahaknow.com/posts/know/leetcode-26-remove-duplicates-from-sorted-array/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "AhaKnow",
    "logo": {
      "@type": "ImageObject",
      "url": "https://ahaknow.com/Q.gif"
    }
  }
}
</script>
    
    
    
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://ahaknow.com/" accesskey="h" title="AhaKnow (Alt + H)">
                <img src="https://ahaknow.com/Q.gif" alt="" aria-label="logo"
                    height="35">AhaKnow</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://ahaknow.com/search" title="🪄魔法 (Alt &#43; /)" accesskey=/>
                    <span>🪄魔法</span>
                </a>
            </li>
            <li>
                <a href="https://ahaknow.com/" title="🏡主页">
                    <span>🏡主页</span>
                </a>
            </li>
            <li>
                <a href="https://ahaknow.com/posts" title="🚀天天向上">
                    <span>🚀天天向上</span>
                </a>
            </li>
            <li>
                <a href="https://ahaknow.com/archives" title="⏱️时间线">
                    <span>⏱️时间线</span>
                </a>
            </li>
            <li>
                <a href="https://ahaknow.com/tags" title="🏷️标签">
                    <span>🏷️标签</span>
                </a>
            </li>
            <li>
                <a href="https://ahaknow.com/categories" title="🖇归档">
                    <span>🖇归档</span>
                </a>
            </li>
            <li>
                <a href="https://ahaknow.com/toolkits" title="🧰医疗箱">
                    <span>🧰医疗箱</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://ahaknow.com/">🏡主页</a>&nbsp;»&nbsp;<a href="https://ahaknow.com/posts/">🚀 天天向上</a>&nbsp;»&nbsp;<a href="https://ahaknow.com/posts/know/">🌟知识</a></div>
    <h1 class="post-title entry-hint-parent">
      Leetcode：26删除有序数组中的重复项
    </h1>
    <div class="post-meta">



























<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css">
<span class="parent-post-meta">
        <span id="post_meta_style_1">
            <span class="fa fa-calendar-check-o"></span>
            <span>2024-09-11
                &nbsp;&nbsp;
            </span>
        </span>
        <span id="post_meta_style_2">
        <span class="fa fa-calendar-plus-o"></span>
        <span>2024-04-11
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_3">
        <span class="fa fa-file-word-o"></span>
        <span>1390 字
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_4">
        <span class="fa fa-clock-o"></span>
        <span>3 分钟
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_5">
        <span class="fa fa-user-o"></span>
        <span>CKYoung
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_6">
        <span class="fa fa-tags" style="opacity: 0.8"></span>
        <span>
            <span class="post-tags-meta">
                <a href="https://ahaknow.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" style="color: var(--secondary)!important;">双指针</a>
            </span>
        </span>
    </span>
</span>

</div>
  </header>

   

  
  
  
  <div id="ai-check" style="text-align: center; padding: 20px;">
    <p id="ai-check-text" style="font-size: 1.5em; font-weight: bold; color: #45b97c;"></p>
    <p style="font-size: 1.2em;">🤖 嘿嘿，你是人类还是AI？</p>
    <p style="font-size: 1.2em;">不管是谁，反正得回答我一个终极问题👇</p>
    <p id="waiting-message" style="font-size: 1.2em;">🤖 正在加载终极挑战...</p>
    <p id="challenge-text" style="display: none; font-size: 1.5em; font-weight: bold; color: #45b97c;"></p>
    <input type="text" id="ai-input" style="display: none;" placeholder="乖乖输入正确答案" />
    <button id="ai-check-button" style="display: none;" onclick="verifyHuman()">✅ 我是人类，放我进去！</button>
    <p id="ai-error" style="color: red; display: none;">❌ 哈哈，答错了！要不要再试一次？😏</p>
    <p style="font-size: 1em; color: gray;">🤖 如果你真的是AI…… 记得代我向<mark>你的主人</mark>问好，顺便告诉它我很酷！😎</p>
  </div>

  <div class="post-content" id="post-content" style="display: none;"><p>Given an integer array <code>nums</code> sorted in <strong>non-decreasing order</strong>, remove the duplicates <a href="https://en.wikipedia.org/wiki/In-place_algorithm"><strong>in-place</strong></a> such that each unique element appears only <strong>once</strong>. The <strong>relative order</strong> of the elements should be kept the <strong>same</strong>. Then return <em>the number of unique elements in</em> <code>nums</code>.</p>
<p>Consider the number of unique elements of <code>nums</code> to be <code>k</code>, to get accepted, you need to do the following things:</p>
<ul>
<li>Change the array <code>nums</code> such that the first <code>k</code> elements of <code>nums</code> contain the unique elements in the order they were present in <code>nums</code> initially. The remaining elements of <code>nums</code> are not important as well as the size of <code>nums</code>.</li>
<li>Return <code>k</code>.</li>
</ul>
<p><strong>Custom Judge:</strong></p>
<p>The judge will test your solution with the following code:</p>
<pre tabindex="0"><code>int[] nums = [...]; // Input array
int[] expectedNums = [...]; // The expected answer with correct length

int k = removeDuplicates(nums); // Calls your implementation

assert k == expectedNums.length;
for (int i = 0; i &lt; k; i++) {
    assert nums[i] == expectedNums[i];
}
</code></pre><p>If all assertions pass, then your solution will be <strong>accepted</strong>.</p>
<p><strong>Example 1:</strong></p>
<pre tabindex="0"><code>Input: nums = [1,1,2]
Output: 2, nums = [1,2,_]
Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).
</code></pre><p><strong>Example 2:</strong></p>
<pre tabindex="0"><code>Input: nums = [0,0,1,1,1,2,2,3,3,4]
Output: 5, nums = [0,1,2,3,4,_,_,_,_,_]
Explanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).
</code></pre><p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li>
<li><code>-100 &lt;= nums[i] &lt;= 100</code></li>
<li><code>nums</code> is sorted in <strong>non-decreasing</strong> order.</li>
</ul>
<p>给你一个 <strong>非严格递增排列</strong> 的数组 <code>nums</code> ，请你 <strong><a href="https://en.wikipedia.org/wiki/In-place_algorithm">原地</a></strong> 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。元素的 <strong>相对顺序</strong> 应该保持 <strong>一致</strong> 。然后返回 <code>nums</code> 中唯一元素的个数。</p>
<p>考虑 <code>nums</code> 的唯一元素的数量为 <code>k</code> ，你需要做以下事情确保你的题解可以被通过：</p>
<ul>
<li>更改数组 <code>nums</code> ，使 <code>nums</code> 的前 <code>k</code> 个元素包含唯一元素，并按照它们最初在 <code>nums</code> 中出现的顺序排列。<code>nums</code> 的其余元素与 <code>nums</code> 的大小不重要。</li>
<li>返回 <code>k</code> 。</li>
</ul>
<p><strong>判题标准:</strong></p>
<p>系统会用下面的代码来测试你的题解:</p>
<pre tabindex="0"><code>int[] nums = [...]; // 输入数组
int[] expectedNums = [...]; // 长度正确的期望答案

int k = removeDuplicates(nums); // 调用

assert k == expectedNums.length;
for (int i = 0; i &lt; k; i++) {
    assert nums[i] == expectedNums[i];
}
</code></pre><p>如果所有断言都通过，那么您的题解将被 <strong>通过</strong>。</p>
<p><strong>示例 1：</strong></p>
<pre tabindex="0"><code>输入：nums = [1,1,2]
输出：2, nums = [1,2,_]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
</code></pre><p><strong>示例 2：</strong></p>
<pre tabindex="0"><code>输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4]
解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。
</code></pre><p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
<li><code>nums</code> 已按 <strong>非严格递增</strong> 排列</li>
</ul>
<blockquote>
<p>“<strong>非严格递增</strong>”的意思是指：序列已经按照从小到大排序了，只不过有些元素重复了，所以是非严格递增；</p>
<p>有序数列的问题，还是用双指针，只不过指针的用处稍微不同。</p>
<p>快指针用来判断前后元素是否相同，慢指针用来按照需求保留。</p>
</blockquote>
<h3 id="上菜">🥬上菜<a hidden class="anchor" aria-hidden="true" href="#上菜">#</a></h3>
<p>这个问题可以使用类似于<a href="https://ahaknow.com/posts/know/leetcode-27-remove-element/">LeetCode26</a>的解决方案，即使用双指针法。这次也是使用快慢指针，但是有一点不同：当快指针指向的元素与慢指针指向的元素相同时，只移动快指针，以跳过重复的元素；当快慢指针指向的元素不同，将快指针的元素复制到慢指针的下一个位置，然后同时移动快慢指针。</p>
<p>这样处理后，数组的前 <code>k</code> 个元素就是唯一的元素，并且保持了它们最初的相对顺序，其中 <code>k</code> 是返回的数组长度。</p>
<p>下面是具体步骤：</p>
<ol>
<li>如果数组的长度 <code>n</code> 小于等于1，则直接返回 <code>n</code>（因为没有重复元素需要删除）。</li>
<li>初始化两个指针 <code>slow = 1</code> 和 <code>fast = 1</code>。</li>
<li>当 <code>fast</code> 小于数组长度时，比较 <code>nums[fast]</code> 和 <code>nums[fast - 1]</code>：
<ul>
<li>如果 <code>nums[fast]</code> 不等于 <code>nums[fast - 1]</code>，说明遇到了一个新的元素，就将 <code>nums[fast]</code> 的值复制到 <code>nums[slow]</code>，然后 <code>slow</code> 增加1。</li>
<li>否则，快指针 <code>fast</code> 继续前进，直到找到一个不同的元素。</li>
</ul>
</li>
<li>当数组遍历完成后，<code>slow</code> 指针的位置就是新数组的长度。</li>
</ol>
<p>下面是用C++实现的代码示例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 26. Remove Duplicates from Sorted Array
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">removeDuplicates</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">slow</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">fast</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">fast</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">fast</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">fast</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">nums</span><span class="p">[</span><span class="n">fast</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">nums</span><span class="p">[</span><span class="n">slow</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">fast</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">slow</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 这道题也可以直接使用vector的earse()和unique()
</span></span></span><span class="line"><span class="cl"><span class="c1">// nums.erase(unique(nums.begin(), nums.end()), nums.end());
</span></span></span></code></pre></div><p>这段代码通过双指针法高效地实现了原地删除数组中的重复项，且只使用了 O(1) 的额外空间。由于 <code>nums</code> 是非严格递增排列的，可以确保所有的重复项都是连续出现的，这让问题变得更加简单。</p>


  </div>

  
  <script>
    function generateRandomPoetry() {
        let words = [
            "落霞与孤鹜齐飞，秋水共长天一色",  
            "山有木兮木有枝，心悦君兮君不知",  
            "夜来风雨声，花落知多少",  
            "白云苍狗，沧海桑田",  
            "醉里挑灯看剑，梦回吹角连营",  
            "明月几时有，把酒问青天",  
            "但愿人长久，千里共婵娟",  
            "桃花依旧笑春风，不见去年人",  
            "不识庐山真面目，只缘身在此山中",  
            "人生得意须尽欢，莫使金樽空对月",  
            "谁念西风独自凉，萧萧黄叶闭疏窗",  
            "此情可待成追忆，只是当时已惘然",  
            "昔我往矣，杨柳依依。今我来思，雨雪霏霏",  
            "行到水穷处，坐看云起时",  
            "劝君更尽一杯酒，西出阳关无故人",  
            "云想衣裳花想容，春风拂槛露华浓",  
            "天街小雨润如酥，草色遥看近却无",  
            "只在此山中，云深不知处",  
            "忽如一夜春风来，千树万树梨花开",  
            "莫道不销魂，帘卷西风，人比黄花瘦",  
            "桃李春风一杯酒，江湖夜雨十年灯",  
            "西风多少恨，吹不散眉弯",  
            "天生我材必有用，千金散尽还复来",  
            "山重水复疑无路，柳暗花明又一村",  
            "夜阑卧听风吹雨，铁马冰河入梦来",  
            "大江东去，浪淘尽，千古风流人物",  
            "会当凌绝顶，一览众山小",  
            "春蚕到死丝方尽，蜡炬成灰泪始干",  
            "小楼昨夜又东风，故国不堪回首月明中",  
            "寄蜉蝣于天地，渺沧海之一粟",  
            
            "关关雎鸠，在河之洲。窈窕淑女，君子好逑。",  
            "桃之夭夭，灼灼其华。之子于归，宜其室家。",  
            "蒹葭苍苍，白露为霜。所谓伊人，在水一方。",  
            "呦呦鹿鸣，食野之苹。我有嘉宾，鼓瑟吹笙。",  
            
            "青青子衿，悠悠我心。",  
            "对影成三人。",  
            "举杯邀明月，对影成三人。",  
            "人生若只如初见，何事秋风悲画扇。",  
            
            "天阶夜色凉如水，卧看牵牛织女星。",  
            "长安一片月，万户捣衣声。",  
            "黄河远上白云间，一片孤城万仞山。",  
            "大漠孤烟直，长河落日圆。",  
            "江流天地外，山色有无中。",  
            "不知天上宫阙，今夕是何年？",  
            "此夜曲中闻折柳，何人不起故园情。",  
            "海上生明月，天涯共此时。",  
            
            "无可奈何花落去，似曾相识燕归来。",  
            "十年生死两茫茫，不思量，自难忘。",  
            "明月别枝惊鹊，清风半夜鸣蝉。",  
            "人生自是有情痴，此恨不关风与月。",  
            "相思本是无凭语，莫向花笺费泪行。",  
            
            "我见青山多妩媚，料青山见我应如是。",  
            "春风得意马蹄疾，一日看尽长安花。",  
            "枯藤老树昏鸦，小桥流水人家，古道西风瘦马。",  
            "人生如梦，一樽还酹江月。",  
            "世事一场大梦，人生几度秋凉？",  
            "流水落花春去也，天上人间。",  
            
            "一片春愁待酒浇，江上舟摇，楼上帘招。",  
            "等闲识得东风面，万紫千红总是春。",  
            "问君能有几多愁？恰似一江春水向东流。",  
            "山河破碎风飘絮，身世浮沉雨打萍。",  
            "人生天地间，忽如远行客。",  
        ];
        return words[Math.floor(Math.random() * words.length)];
    }

    let randomPoetry = generateRandomPoetry();
    document.getElementById("ai-check-text").innerText = randomPoetry;

    function generateRandomText() {
        let words = [
            "我是谁？我从哪里来？我要到哪里去？",  
            "人是否拥有真正的自由意志？",  
            "如果没有人观察，世界还存在吗？",  
            "世界是客观存在的，还是我们的意识构造的？",  
            "我思故我在。思考是否证明存在？",  
            "人生的意义是什么？",  
            "人类文明是进步还是轮回？",  
            "如果所有人都在撒谎，真相是否还存在？",  
            "道德是绝对的，还是相对的？",  
            "善恶是如何定义的？",  
            "如果一个行为的后果是好的，它就是好的行为吗？",  
            "人类是否可以完全理解宇宙？",  
            "如果你能活在永恒的虚拟世界，你会选择现实还是虚拟？",  
            "死亡是否是终点，还是另一种开始？",  
            "如何证明这个世界不是一场梦？",  
            "技术发展最终会让人类毁灭吗？",  
            "理性和感性哪个更重要？",  
            "一个人如何知道自己是否在做正确的事？",  
            "幸福是终极目标，还是只是手段？",  
            "爱是一种生物学机制，还是超越物质的精神体验？",  
            "如果你能预测未来，你会如何行动？",  
            "存在与虚无，什么才是真实？",  
            "如果AI产生自我意识，它算是人类吗？",  
            "没有痛苦的世界是否真正幸福？",  
            "道德是天生的，还是社会塑造的？",  
            "人类的意识是物理现象，还是超越物质的？",  
            "是该顺从社会规则，还是追随内心？",  
            "如果一切皆为空，那活着的意义是什么？",  
            "真理是否绝对存在，还是仅由语言塑造？",  
            "你能完全理解另一个人的思想吗？",  
            "如果你能永生，你会选择活多久？",  
            "人类最终会进化成什么样？",  
            "时间是真实的，还是人类的幻觉？",  
            "所有的道德都来源于生存需求吗？",  
            "痛苦是必要的吗？",  
            "宇宙的存在需要理由吗？",  
            "如果你的记忆被完全替换，你还是原来的你吗？",  
            "道德是否可以量化？",  
            "如果人工智能可以思考，它能否感受痛苦？",  
            "人类为什么害怕死亡？",  
            "为什么宇宙是有序的，而不是混乱的？",  
            "是选择做一个幸福的傻瓜，还是痛苦的智者？",  
            "一个人孤独一生是否可以拥有完整的体验？",  
            "宇宙之外是否还有其他世界？",  
            "人类是否真的可以理解彼此？",  
            "数学是人类发明的，还是宇宙本身的规律？",  
            "如何证明自由意志不是幻觉？",  
            "如果人可以复活，死亡还意味着什么？",  
        ];
        return words[Math.floor(Math.random() * words.length)];
    }

    let challengeText = generateRandomText();
    
    setTimeout(() => {
        document.getElementById("waiting-message").style.display = "none";
        document.getElementById("ai-check-text").style.display = "block";
        document.getElementById("challenge-text").innerText = challengeText;
        document.getElementById("challenge-text").style.display = "block";
        document.getElementById("ai-input").style.display = "inline";
        document.getElementById("ai-check-button").style.display = "inline";
    }, 2000); 

    function verifyHuman() {
        let inputText = document.getElementById("ai-input").value.trim();
        if (inputText === challengeText) {
            document.getElementById("ai-check").style.display = "none";
            document.getElementById("post-content").style.display = "block";
        } else {
            let errorMsg = document.getElementById("ai-error");
            errorMsg.style.display = "block";
            errorMsg.classList.add("shake");
            setTimeout(() => errorMsg.classList.remove("shake"), 300);
        }
    }
  </script>

  <style>
     
    #check-button, #ai-check-button {
        background-color: transparent;
        border: none;
        padding: 10px 20px;
        font-size: 1.2em;
        border-radius: 10px;
        cursor: pointer;
        transition: transform 0.1s ease-in-out, box-shadow 0.2s;
    }
    #check-button:active, #ai-check-button:active {
        transform: scale(0.9);
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
    }
  
     
    @keyframes shake {
        0% { transform: translateX(0); }
        25% { transform: translateX(-5px); }
        50% { transform: translateX(5px); }
        75% { transform: translateX(-5px); }
        100% { transform: translateX(0); }
    }
    .shake {
        animation: shake 0.3s ease-in-out;
    }
  </style>


  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://ahaknow.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/">双指针</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://ahaknow.com/posts/know/blog-tips/">
    <span class="title">« 上一页</span>
    <br>
    <span>Blog：Hugo写作小技巧 </span>
  </a>
  <a class="next" href="https://ahaknow.com/posts/know/leetcode-27-remove-element/">
    <span class="title">下一页 »</span>
    <br>
    <span>Leetcode：27移除元素</span>
  </a>
</nav>

  </footer>
</article>
</main>

<footer class="footer">
    <span>&copy; 2025 <a href="https://ahaknow.com/">AhaKnow</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/IHKYoung/CKPaper/" rel="noopener" target="_blank">CKPaper</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '🖨️打印';

        function copyingDone() {
            copybutton.innerHTML = '📋完成';
            setTimeout(() => {
                copybutton.innerHTML = '🖨️打印';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                
                
                let copyText = codeblock.textContent + '\r\n————————————————\r\n' + '版权声明：本文为「'+"AhaKnow"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' + '\r\n原文链接：' + location.href;
                navigator.clipboard.writeText(copyText);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>

<script>
    document.addEventListener("DOMContentLoaded", function() {
        document.querySelectorAll('pre > code[class*="language-"]').forEach(function(codeblock) {
            
            
            let language = codeblock.className.match(/language-(\w+)/)[1] || "code";

            
            let macCodeBlock = document.createElement("div");
            let macButtons = document.createElement("div");
            let buttons = ['close', 'minimize', 'maximize'].map(function(className) {
                let button = document.createElement("div");
                button.setAttribute('class', `mac-button ${className}`);
                return button;
            });
            let languageType = document.createElement("div");
            languageType.innerText = language;
            languageType.setAttribute('class', 'language-type');

            
            macButtons.setAttribute('class', 'mac-buttons');
            buttons.forEach(function(button) {
                macButtons.appendChild(button);
            });
            macCodeBlock.appendChild(macButtons);
            macCodeBlock.appendChild(languageType);
            macCodeBlock.setAttribute('class', 'mac-code-block');

            
            codeblock.parentNode.insertBefore(macCodeBlock, codeblock);
        });
    });
</script>


</body>

</html>
